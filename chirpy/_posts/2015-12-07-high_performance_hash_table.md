---
title: 一种高性能多阶哈希表实现
date: 2015-12-07 21:45:00 +0800
categories: [algorithm]
tags: [hash]
math: false
---
## 概述

本文提出一种改进版的多阶哈希表实现 -- 等比多阶哈希表，相对于当前服务器后台所常用的多阶哈希表，在空间利用率类似的情况下，可将有效查询的性能提升约10倍，空查询的性能约提升约3~4倍。

## 背景

多阶哈希表由于其结构简单稳定、易于在共享内存中实现等优点在服务器开发中广泛采用。目前常用的多阶哈希表，由一个近似R行C列的矩阵式数组来实现，多行用于通过多次哈希来解决哈希冲突。每一行的哈希算法为`Key % 质数(C,r)`，其中`r`为当前行号，`质数(C,r)`为小于C的第r个质数。

查找与插入操作的示例伪代码为：

	bool HashTableFind(Key k)
	{
	  for (int r = 0; r < R; r++) {
	    int c = k % GetPrime(r);
	    if (GetKey(r, c) == k) {
	      return true;
	    }
	  }
	  return false;
	}
	
	bool HashTableInsert(Key k)
	{
	  if (HashTableFind(key))
	    return false;
	  for (int r = 0; r < R; r++) {
	    int c = k % GetPrime(r);
	    if (IsHashNodeEmpty(r, c)) {
	      SetHashNode(r, c, k);
	      return true;
	    }
	  }
	  return false;
	}

该哈希表算法的一个关键参数为`R`(行数)，R数的取值影响查询效率和空间利用率。查询效率与R成反比，因为有效查询的平均比较次数为`R/2`，空查询的比较次数为`R`，R越大查询效率越低。空间利用率与R成正比，关系如下图(x轴为R取值，y轴为空间利用率)：

![row_vs_usage](/res/201512-high_performance_hash_table/fix_ht_usage_vs_rows.png)

一个广泛应用的R的经验值是50，此时空间利用率在90%以上，（有效查询）平均比较次数25次，最大(空查询)比较次数50次，单核平均有效查询性能约`200+万/秒`，空查询`100+万/秒`。这个性能数据在高并发场景下并不算特别理想，设想服务器每个请求需做100次哈希表查询，则单核每秒最多处理不到2万次请求。对比std::unordered_map等开链式哈希表实现（查询性能接近1000万/秒），多阶哈希表性能相比也偏低。基于本实现一种简单的提升查询效率的方式是减少阶数（须同时增大列数），但会以大幅降低空间利用率为代价。

## 改进设计

改进的核心思想是让更多的哈希节点集中于哈希表的头几行，以减小平均节点深度，从而缩小查询操作时的平均比较次数。另外一个需要考虑的因素是需要保证空间的利用率，特别是占有大量节点的头几行如果利用率不高，则整体利用率会受较大影响。我们先以单行节点为例分析，如何保证利用率？通过简单的概率分析可知，单行节点占用率（即非空节点数比上单行总节点数）与该行上随机写入的次数成非线性的单调递增关系，如下图所示：

![row_vs_usage](/res/201512-high_performance_hash_table/array_usage_vs_rand_writes.png)

从上图可以看出在近似随机写入的情况下，`写入数/单行节点数`决定了该行的占用率，如随机写入1倍节点数时，节点占用率约在60%多，2倍节点数时达到80%多，随着写入数的继续增加节点占用率逐渐缓慢增长逼近100%。从这里我们可得一个思路，如果能保证多阶哈希被填满时，其中每一阶(行)的写入次数/该行节点数大于某个系数(如大于2)，即可保证该行的利用率达到某一比例(如大于80%)。同时注意到，在多阶哈希表的结构中，每一阶(行)写入次数实际就是该阶(行)及以下所有阶(行)的节点总数。由此可得，保证`单阶节点数/该阶及以下阶总节点数`大于某个常数，一个简单直接的方式就是构造一个多阶哈希表，唯一与原来不同的是，各阶节点数近似组成一个系数为`ratio (0<ratio<1)`的等比数列，如下表所示：

	第0阶： 质数(C, 1) 个节点
	第1阶： 质数(C * ratio, 1) 个节点
	第2阶： 质数(C * ratio^2, 1) 个节点
	 ...   ...
	第n阶： 质数(C * ratio^n, 1) 个节点
	 ...   ...
	第N阶： 2个节点 [质数(C * ratio^N, 1) == 2)]

哈希表的总节点数M，最大阶数N，首阶节点数C，平均节点深度D近似符合如下关系：

	M ~= C/(1-ratio)
	N ~= log(C, 1/ratio)
	D ~= 1/(1-ratio)

接下来的问题是ratio具体应该怎么取值，下图分析了ratio取不同值时，哈希表的空间利用率与平均节点深度的变化关系：

![row_vs_usage](/res/201512-high_performance_hash_table/ht_usage_depth_vs_ratio.png)

由上图可以看出，空间利用率与平均节点深度是两个互相有冲突的特性，当ratio取接近0时，哈希表总体阶数变小，平均节点深度变小，但空间利用率也较小；反之，当ratio取值接近1时，哈希表总体阶数变大，平均节点深度变大，但空间利用率也较大。从这两个曲线中可以得到，ratio取值一个比较好的tradeoff是`0.6`左右，这时的空间利用率在`85%`以上，平均节点深度在`2.5`左右。

最后我们再来关注一个指标，多阶哈希表的阶数。以首阶100万节点，ratio=0.6的等比多阶哈希表为例，它的阶数为26，它代表了在查找最坏情况或空查询的情况下，需要26次比较操作。有没有进一步优化空间呢，答案是肯定的，下图是对于刚才26阶等比哈希表，截取前n阶时(0<n<27)的空间利用率和平均节点深度的变化：

![row_vs_usage](/res/201512-high_performance_hash_table/ht_250w_ratio60_rows.png)

可以看到在这个例子中，当阶数达到15阶时，整个哈希表的空间利用率及平均节点深度的指标上已经非常接近于26阶时的情况。所以一个优化是最大阶数缩减，具体做法是对于算法理论阶数x，我们在不显著影响性能指标的情况下将其它缩减为effective\_rows(x)。经过测试分析(细节这里不再展开)，我们发现effective\_rows函数不是一个常数，也不是一个关于x的线性函数，而是一个斜率递减的上凸曲线，经过一些分析，我们找到一个较为简单的幂函数可以近似描述这个函数：

	effective_rows(x) = min(x, 3 * x^0.5)

下图展示了effective\_rows的有效性，当首阶节点数从100到1000000取值时，等比多阶哈希的理论阶数取值为5到26，将这个理论最大阶数设定为x轴，将实际使用的阶数设为y轴，黑色的曲线表示空间使用率达到最大使用率的`98%`时所需的实际阶数，红色曲线表示使用effective\_rows函数拟合的曲线，从图中可以看出，effective\_rows近似拟合了黑色曲线，也就是表示说用effective\_rows函数来设定的哈希表的实际阶数，能够保持`98%`的原空间利用率效果(根据前面分析平均节点深度也类似)。

![row_vs_usage](/res/201512-high_performance_hash_table/effective_rows.png)


## 结论

本文给出了基于原多阶哈希表的一种改进实现 -- 等比多阶哈希表。它的每阶节点数按照`0.6`的比例逐阶收敛，阶数为`min(x，3*x^0.5)`，其中x为按0.6比例收敛的理论阶数，阶数随总节点数大小而变动，通常取值范围在`12～16`左右。该等比多阶哈希表空间利用率在`85%`以上，有效查询平均比较次数`2.5`左右，约是原多阶哈希表的10倍，性能约在`2000万/秒`以上，最坏或空查询比较次数在12~16左右，约是原多阶哈希表的`3~4`倍。
